# üîê Crypto Challenge

## üè∑Ô∏è Name: [Tsayaki](https://app.hackthebox.com/challenges/662)

## üî• Difficulty: Hard

## üéØ Points: 0

## ‚è≥ Status: üü• Retired

## üìú Challenge Description: 
> You find yourself in the middle of a deadly ancient maze. The maze sprawls before you, its secrets veiled in shadows, its gates locked tight against intruders. With thousands of keys shimmering under the harsh light, you steel yourself for the daunting challenge ahead. Each chamber of the maze presents a new puzzle to unravel, each gate a barrier to overcome. Armed with determination and resolve, you set forth into the labyrinth&#039;s depths, knowing that your survival hinges on unlocking the path forward by finding the proper key. With each new chamber you enter, you are greeted with a cup of tea‚Äîa brief respite from the perilous journey that lies ahead. But the tea is not the only gift bestowed upon you in these chambers. With each cup, you receive a hint that will guide you on how to move on.

## üìÇ Provided Files:
- **Filename:** `Tsayaki.zip`

- **SHA-256 Hash:** `ba80a0d14e2db3417861b5e32af569066c47e794f81fabf6a50d4a3959cc4a3c`

# üöÄ Methodology

### üîé 1Ô∏è‚É£ Understanding the Cryptosystem

--- 

First of all, the source of the cryptosystem is not included, but we can assume that `'tea'` is Tiny Encryption Algorithm (TEA). I had solved this challenge during the CTF (can't remember which one it was), and I'm pretty sure another easier retired challenge actually has the source code. So the file Tea_User.py is more or less the the source code. My old solution is included. It's honestly not that nice - I had a phase with experimenting with Python classes ü´†.

The server is pretty simple:

- A random 20-byte message is generated by the server:
  
  ```python
  server_message = os.urandom(20)
  ```

  This is printed to us at the start of the game ‚Äî it's our known plaintext.

---


There are **10 rounds**, and each round consists of **4 key attempts** (or "subrounds").

The core of each round goes like this:

1. It asks us to input a **target ciphertext**. This is the ciphertext we want the server to ‚Äúmatch‚Äù during its internal checks.
2. Then, **4 times**, it asks us for a 16-byte encryption key (also in hex).
3. For each of those 4 keys:
   - It uses the TEA cipher with **our submitted key** and a **fixed IV** (which is unknown to the client).
   - It encrypts the `server_message` with that key and IV.
   - If the resulting ciphertext doesn't match the one we submitted, we're kicked out. But the server is nice enough to print the ciphertext it generated ‚Äî which gives us an oracle to compare against.

Finally, if all 4 keys for that round produce the same ciphertext we submitted, the round passes, and the game continues to the next one.

**Key Points:**

- We can't reuse ciphertexts.
- We can't reuse keys.
- Keys must be exactly 16 bytes.

Therefore, we must find:
   - 10 target ciphertexts (one per round)
   - 4 different keys that all produce the same ciphertext when encrypting the server message.


### ‚ö° 2Ô∏è‚É£ Identifying Vulnerabilities

---

To start, we need to find a way to recover the IV. Luckily, it‚Äôs **fixed** ‚Äî meaning even if we get kicked out, we can just try again... and again... and again.

---

The encryption uses **CBC (Cipher Block Chaining) mode**, which works like this:

1. The message is padded (probably with nulls or PKCS#7-style).
2. It's split into **8-byte blocks** (since TEA is a 64-bit block cipher).
3. Encryption then proceeds block by block as follows:

Let the plaintext blocks be:
$$P_1, P_2, P_3$$
and the ciphertext blocks be:
$$C_1, C_2, C_3$$

Let $IV$ -  (the unknown we want to recover). Then the encryption proceeds like this:

$$
\begin{aligned}
C_1 &= E_K(P_1 \oplus IV) \\
C_2 &= E_K(P_2 \oplus C_1) \\
C_3 &= E_K(P_3 \oplus C_2)
\end{aligned}
$$

Where:
- $E_K$ is the block encryption function using key $K$

---

Since the server message is **always 20 bytes**, and TEA uses 8-byte blocks, the message will be split into **3 blocks** (after padding).



### üî® 3Ô∏è‚É£ Exploiting the Weakness

### 1. Recovering the IV

   The IV Recovery is easy. Instead of using the CBC Mode, we use ECB Mode. 

   We send the server some key $K$. The server encrypt the server_message using CBC mode.

   We create a 'ECB' mode cipher:

 ```python

    from pwn import remote
    from Tea_User import Cipher as TEA

    key = bytes(16)
    cipher_ecb = TEA(key)

    conn = remote('94.237.60.64','37970')
    conn.recvuntil(b'Here is my special message: ')
    server_message = bytes.fromhex(conn.recvline().decode().strip())

    conn.sendlineafter(b'Enter your target ciphertext (in hex) : ',bytes(16).hex().encode())
    conn.sendlineafter(b'Enter your encryption key (in hex) : ',key.hex().encode())
    conn.recvuntil(b'Hmm ... close enough, but ')
    enc = bytes.fromhex(conn.recvuntil(b' ').decode().strip())

    dec_block = cipher_ecb.decrypt_block(enc[:8])
    IV = cipher_ecb._xor(dec_block,server_message[:8])

    assert TEA(key,IV).encrypt(server_message) == enc
    
    conn.close()

  ```

**IV:** `55b50e3afaed3d99`


 --- 

### 2. Finding colliding keys

   Doing some research on [Tiny Encryption Algorithm (TEA)](https://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm) it validates the purpose of the challenge:

>**"TEA has a few weaknesses. Most notably, it suffers from equivalent keys‚Äîeach key is equivalent to three others, which means that the effective key size is only 126 bits. As a result, TEA is especially bad as a cryptographic hash function. Because of these weaknesses, the XTEA cipher was designed."**



   And to be clear: the server definitely isn‚Äôt using XTEA lol.

   The Wikipedia page conveniently provides a link to the original paper by Kelsey, Schneier, and Wagner‚Äî[Key-Schedule Cryptanalysis of IDEA, G-DES, GOST, SAFER, and Triple-DES (1996)](https://doi.org/10.1007/3-540-68697-5_18), which explains why and how these equvalent keys work.

   The **TEA (Tiny Encryption Algorithm)** master key is 128 bits, split into four 32-bit words:  
   $$K = [K_0, K_1, K_2, K_3]$$

   During encryption:
   - **Odd rounds** use $K_0, K_1$
   - **Even rounds** use $K_2, K_3$


The plaintext block (in our case it is xored with the IV), is split into  two 32-bit halves $Y,Z$.


The round function F is:

$$\begin{aligned}
F_i(z, k, k') &= \left( (z \ll 4) + k \right) \\
            &\quad \oplus \left( z + C_i \right) \\
            &\quad \oplus \left( (z \gg 5) + k' \right)
\end{aligned}$$

The paper further explains that the TEA round function has a big fault:  **complementing the most significant bit** (bit 31) of the key words has no effect on the final ciphertext. This is due to the way bit shifts and XOR operations cancel out across rounds.


So, from any key \([K_0, K_1, K_2, K_3]\), we can derive three **cryptographically equivalent keys** by flipping the MSB of various key words:

$$\begin{aligned}
\text{KEY}_0 &= [K_0, \quad K_1, \quad K_2, \quad K_3] \\
\text{KEY}_1 &= [K_0 \oplus 2^{31}, \quad K_1 \oplus 2^{31}, \quad K_2, \quad K_3] \\
\text{KEY}_2 &= [K_0 \oplus 2^{31}, \quad K_1 \oplus 2^{31}, \quad K_2 \oplus 2^{31}, \quad K_3 \oplus 2^{31}] \\
\text{KEY}_3 &= [K_0, \quad K_1, \quad K_2 \oplus 2^{31}, \quad K_3 \oplus 2^{31}]
\end{aligned}$$

This means that encrypting the same plaintext with any of these keys will yield the **same ciphertext**. 



üß™ Testing Collisions

 ```python

    from Crypto.Util.number import bytes_to_long as b2l,long_to_bytes as l2b
    from Tea_User import Cipher as TEA
    import operator

    def test_collision(key,msg,dbg=False,IV=b'U\xb5\x0e:\xfa\xed=\x99'):
        K0,K1,K2,K3 =  [b2l(key[i:i+4]) for i in range(0, len(key), 4)]
        BITS_FLIP = 0x80000000
        KEY_0 = [K0,K1,K2,K3]
        KEY_1 = [operator.xor(K0,BITS_FLIP),operator.xor(K1,BITS_FLIP),K2,K3]
        KEY_2 = KEY_1[:2] + [operator.xor(K2,BITS_FLIP),operator.xor(K3,BITS_FLIP)]
        KEY_3 = KEY_0[:2] + KEY_2[-2:]
        m_values = []
        for K in [KEY_0,KEY_1,KEY_2,KEY_3]:
            key_ = b''.join(l2b(x) for x in K)
            m = TEA(key_,IV).encrypt(msg)
            m_values.append(m)
        return len(set(m_values)) == 1 if not dbg else m_values

    for _ in range(200):
        server_message = os.urandom(20)
        for _ in range(10):
            key = os.urandom(16)
            assert test_collision(key,server_message)

 ```

 and this raised in an error! let's investigate why. 

The key that produced an error is:
```
13f49094809ba5d75de2c15c636048b9
```

It produced two valid collisions for KEY_1 and KEY_3. 
The reason why it raised an error is because  `K1 = 0x809BA5D7`, which begins with the byte `0x80`, which also the first byte of the mask used to derive equivalent keys. This means that when we XOR this byte with `0x80` (To flip the MSB of the first byte), it becomes `0x00`, which **may cause no effective change or introduce problematic null bytes**.

Now, let's see what happens if we modify that key:

```python

new_key = key[:4] + bytes([12]) + key[5:]
assert test_collision(new_key,server_message)

```

All good ! So we just need to make sure that the `0x80` and `0x00` are not in the key. 

```python
    for _ in range(200):
        server_message = os.urandom(20)
        for _ in range(10):
            key = os.urandom(16)
            if 0 in key or 128 in key:
                continue
            assert test_collision(key,server_message)
```

and that works perfectly fine !



### üîë 4Ô∏è‚É£ Recovering the Flag

Now all we have to do is communicate with the server again. This time, upon receiving the server message, we can calculate the keys directly. After 10 rounds we get the FLAG !

# üèÅ Solution & Commands

```python

from Tea_User import Cipher as TEA
from Crypto.Util.number import bytes_to_long as b2l, long_to_bytes as l2b
import operator
from pwn import remote
import os


def make_collision(key,message,IV =b'U\xb5\x0e:\xfa\xed=\x99'):
    K0,K1,K2,K3 =  [b2l(key[i:i+4]) for i in range(0, len(key), 4)]
    BITS_FLIP = 0x80000000
    KEY_0 = [K0,K1,K2,K3]
    KEY_1 = [operator.xor(K0,BITS_FLIP),operator.xor(K1,BITS_FLIP),K2,K3]
    KEY_2 = KEY_1[:2] + [operator.xor(K2,BITS_FLIP),operator.xor(K3,BITS_FLIP)]
    KEY_3 = KEY_0[:2] + KEY_2[-2:]
    m_values = set()
    KEYS = []
    for K in [KEY_0,KEY_1,KEY_2,KEY_3]:
        key_bytes =  b''.join([l2b(x) for x in K])
        m = TEA(key_bytes,IV).encrypt(message)
        m_values.add(m)
        KEYS.append(key_bytes.hex())
    assert len(m_values) == 1
    return m.hex(),KEYS

def generate_pairs(server_message):
    colliding_pairs = []
    while len(colliding_pairs) != 10:
        try:
            key = os.urandom(16)
            if 0 in key or 128 in key:
                continue
            colliding_pairs.append(make_collision(key,server_message))
            print(F'Found equivalent keys for {key.hex()}')
        except:
            continue
    return colliding_pairs

def recover_iv(host,port):
    key = bytes(16)
    cipher_ecb = TEA(key)

    conn = remote(host,port)
    conn.recvuntil(b'Here is my special message: ')
    server_message = bytes.fromhex(conn.recvline().decode().strip())

    conn.sendlineafter(b'Enter your target ciphertext (in hex) : ',bytes(16).hex().encode())
    conn.sendlineafter(b'Enter your encryption key (in hex) : ',key.hex().encode())
    conn.recvuntil(b'Hmm ... close enough, but ')
    enc = bytes.fromhex(conn.recvuntil(b' ').decode().strip())

    dec_block = cipher_ecb.decrypt_block(enc[:8])
    IV = cipher_ecb._xor(dec_block,server_message[:8])

    assert TEA(key,IV).encrypt(server_message) == enc
    
    conn.close()
    return IV



IV = recover_iv(host,port)
print(f'Recovered IV : {IV.hex()}')

conn = remote(host,port)

conn.recvuntil(b'Here is my special message: ')
server_message = bytes.fromhex(conn.recvline().decode().strip())

colliding_pairs = generate_pairs(server_message)


for round in range(10):
    ct,keys = colliding_pairs[round]
    conn.sendlineafter(b'Enter your target ciphertext (in hex) : ',ct.encode())
    for i in range(4):
        conn.sendlineafter(b'Enter your encryption key (in hex) : ',keys[i].encode())


FLAG = conn.recvline().decode().strip()
print(FLAG)

```

**üö© Final Flag:** `HTB{y0u_b3tt3r_n0t_us3_t34_f0r_h4sh1ng}`

