# 🔐 Crypto Challenge

## 🏷️ Name: [TurboCipher](https://app.hackthebox.com/challenges/401)

## 🔥 Difficulty: Medium

## 🎯 Points: 0

## ⏳ Status: 🟥 Retired

## 📜 Challenge Description: 
> In a parallel universe, all recursive algorithms are strictly forbidden by the &amp;quot;coding laws&amp;quot;. For this reason, students must solve a different recursion-based problem each year at the beginning of their CS studies. This year, it is a difficult encryption method that requires a high level of math skills. Can you solve it?

## 📂 Provided Files:
- **Filename:** `TurboCipher.zip`

- **SHA-256 Hash:** `5179dc819f43714a985fafb26fae053c79c303b5fd4b8a98baae2bc0400c8f6f`

# 🚀 Methodology

## 🔎 1️⃣ Understanding the Cryptosystem  

This is a **custom encryption scheme** that combines multiple mathematical concepts.  

### **1.1 Turbonacci**  

We are given the `turbonacci` and `turbocrypt` functions, but **not** the `fast_turbonacci` & `fast_turbocrypt` implementations.  
For the numbers generated by the system (**512-bit primes**), the naive implementations of these functions would take an impractical amount of time to compute.  

The **Turbonacci sequence** is a **modified Fibonacci sequence**, using two generated primes, **b** and **c**, as coefficients:

$$T(n) = (b \cdot T(n-1) + c \cdot T(n-2)) \mod p$$

where:
- \( b, c, p \) are **given parameters**.
- The sequence follows a **linear recurrence relation**.

Since the computation is done **modulo `p`**, it remains computationally feasible.

To efficiently compute `fast_turbonacci(n, p, b, c)`, we recognize that **linear recurrence relations** can be solved using **matrix exponentiation**.

#### **Efficient Computation Using SageMath**  
In **SageMath**, we can implement `fast_turbonacci` as:

```python
def fast_turbonacci(n, p, b, c):
    m = matrix(Zmod(p), [[b, 1], [c, 0]])
    return (m**n)[0][1]
```

The server provides a **nonce**, and we must compute its `otp` using `fast_turbonacci` with the given parameters to authenticate.

---

### **1.2 Turbocrypt**  

#### **Inputs:**
- `plaintext (pt)`: The message to encrypt, represented as an **integer**.
- `k`: A **512-bit prime** used as part of the encryption.
- `f(x)`: A **Linear Congruential Generator (LCG)**, defined as:

$$
f(x) = (m \cdot x + n) \mod p
$$

  where \( m, n, p \) are **512-bit primes**.

---

#### **Fundamental Issue: LCG is Static**  
A normal **LCG** is a PRNG (**Pseudorandom Number Generator**) that **updates its state** iteratively:

$$
x_{n+1} = (a \cdot x_n + c) \mod m
$$

However, **in `turbocrypt`, `f(x)` does not update its state**. Instead, it is simply a **linear function**:

$$
f(x) = (m \cdot x + n) \mod p
$$

This means **no randomness is introduced**—`f(x)` is fully predictable.

---

#### **Breaking Down `turbocrypt`**
The function is defined as:

```python
def turbocrypt(pt: int, k: int, f: Callable[[int], int]) -> int:
    return sum((f(i + 1) - f(i)) for i in range(k, pt))
```

Expanding the summation:

$$
\sum_{i=k}^{pt-1} \left( f(i+1) - f(i) \right)
$$

Each term evaluates to:

$$
f(i+1) - f(i) = \left( (m \cdot (i+1) + n) - (m \cdot i + n) \right) = m
$$

Thus, the entire sum simplifies to:

$$
\text{ct} = m \cdot (pt - k) \mod p
$$

Rewriting:

$$
\text{ct} = (-k \cdot m + m \cdot pt) \mod p
$$

Since the encryption process is **just a linear transformation**, the key idea for decryption is **recovering `m` and `k`**.

---

## ⚡ 2️⃣ Identifying Vulnerabilities  

Since `turbocrypt` is just a **linear function**, we can **recover `m` and `k`** with a **chosen plaintext attack**.

### **Extracting `m`**
To extract `m`, we choose two plaintext values:

1. \( pt_1 = pt \)
2. \( pt_2 = pt + 1 \)

Encrypting both:

$$
\text{ct}_1 = (m \cdot (pt - k)) \mod p
$$
$$
\text{ct}_2 = (m \cdot ((pt + 1) - k)) \mod p
$$

Subtracting the two equations:

$$
(\text{ct}_2 - \text{ct}_1) \mod p = m
$$

Thus, we can compute `m` as:

```python
m = (ct2 - ct1) % p
```

---

### **Extracting `k`**
From the first encryption equation:

$$
\text{ct}_1 = (-k \cdot m + m \cdot pt) \mod p
$$

Rearranging:

$$
k = -((\text{ct}_1 / m) - pt) \mod p
$$

Thus, `k` can be recovered with:

```python
k = -((ct1 / m) - pt) % p
```

---

## 🔨 3️⃣ Exploiting the Weakness  

Now that we have `m` and `k`, we can **decrypt any ciphertext**.

For the encrypted flag:

$$
\text{flag} = \left( \frac{\text{flag enc}}{m} + k \right) \mod p
$$

Which in Python is:

```python
flag = ((flag_enc / m) + k) % p
```

Since `m` and `k` are already **extracted**, the flag can now be fully decrypted.

---

## 🔑 4️⃣ Recovering the Flag  

To summarize, the **attack strategy** is:

1. **Compute `m`** by encrypting `pt` and `pt + 1`:
   ```python
   m = (ct2 - ct1) % p
   ```

2. **Compute `k`** using:
   ```python
   k = -((ct1 / m) - pt) % p
   ```

3. **Decrypt the flag**:
   ```python
   flag = ((flag_enc / m) + k) % p
   ```

Since `turbocrypt` is **completely linear**, the encryption scheme is fully broken, and the flag can be recovered.

---




# 🏁 Solution & Commands

```python

from pwn import remote
from Crypto.Util.number import bytes_to_long as b2l, long_to_bytes as l2b, getPrime
import string
import random

def fast_turbonacci(n,p,b,c):
    m = matrix(Zmod(p),[[b,1],[c,0]])
    return (m**n)[0][1]

def fast_turbocrypt(m,k,x,p):
    return (m*(x-k))%p


conn = remote(host,port)
conn.recvuntil(b' Parameters:\n')
p = int(conn.recvline().decode().strip().split('= ')[1])
b = int(conn.recvline().decode().strip().split('= ')[1])
c = int(conn.recvline().decode().strip().split('= ')[1])
conn.recvuntil(b'nonce = ')
nonce = int(conn.recvuntil(b' ').decode().strip())

otp = fast_turbonacci(nonce,p,b,c)
conn.sendlineafter(b'OTP: ',str(otp).encode())
valid = conn.recvline().decode().strip()
assert valid == 'Login successful'

pt = bytes(random.sample(string.printable.encode(),64))
pt1 = l2b(b2l(pt)+1).decode()
conn.sendlineafter(b'> ',b'2')
conn.sendlineafter(b"pt = ",pt.decode())
ct1 = ZZ(conn.recvline().decode().strip().split('= ')[1])

conn.sendlineafter(b'> ',b'2')
conn.sendlineafter(b"pt = ",pt1)
ct2 = ZZ(conn.recvline().decode().strip().split('= ')[1])

m = ((ct2-ct1)%p)
assert is_prime(m)
k = -((ct1/m)-b2l(pt))%p
assert is_prime(k)

conn.sendlineafter(b'> ',b'1')
flag_enc = ZZ(conn.recvline().decode().strip().split('= ')[1])
flag = l2b( ((flag_enc/m)+k)%p)

print(flag.decode())


```

**🚩 Final Flag:** `HTB{C4lcU1u5_m33t5_Cryp70_c4n_y0u_8e1i3ve_17???}`

